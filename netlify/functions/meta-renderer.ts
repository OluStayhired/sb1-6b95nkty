//import { createClient } from '@supabase/supabase-js';
import * as fs from 'fs';
import * as path from 'path';

const { createClient } = require('@supabase/supabase-js');

// --- Configuration (Pulling from Netlify Environment Variables) ----
const SUPABASE_URL = process.env.SUPABASE_URL;
const SUPABASE_ANON_KEY = process.env.SUPABASE_ANON_KEY;

if (!SUPABASE_URL || !SUPABASE_ANON_KEY) {
    console.error("Supabase environment variables are not set. The function will fail.");
}

const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY); 

// List of file extensions that should bypass the function and fall through to static assets.
const ASSET_EXTENSIONS = ['.js', '.css', '.ico', '.png', '.jpg', '.jpeg', '.svg', '.gif', '.webmanifest', '.map', '.json', '.tsx'];

// Define the path to the built index.html.
// This assumes the function is in 'netlify/functions' and the built files are in 'dist'.
// This path might need slight adjustment based on your specific Netlify build structure.
const BUILT_INDEX_PATH = path.join(__dirname, '..', '..', 'dist', 'index.html');
const PLACEHOLDER = '<!---- DYNAMIC_META_INJECTION ---->';

let htmlTemplate = null; // We will load this once if possible

// Function to load the static HTML template from the build output
function loadHtmlTemplate() {
    try {
        console.log(`Attempting to read template from: ${BUILT_INDEX_PATH}`);
        // Read the content of the index.html file generated by the build. 
        // This file contains the correct, hashed path to the main JavaScript bundle.
        htmlTemplate = fs.readFileSync(BUILT_INDEX_PATH, 'utf8');
        if (!htmlTemplate.includes(PLACEHOLDER)) {
            console.warn(`CRITICAL WARNING: The placeholder "${PLACEHOLDER}" was not found in the built index.html. Meta tags will not be injected.`);
        }
        return true;
    } catch (e) {
        console.error('Failed to load static index.html template:', e.message);
        return false;
    }
}


export async function handler(event, context) {
    const requestedPath = event.path;
    const BLOG_PREFIX = '/blog/';

    // Ensure the HTML template is loaded once.
    if (!htmlTemplate) {
        if (!loadHtmlTemplate()) {
            return { statusCode: 500, body: 'Template loading failed.' };
        }
    }

    console.log(`Request received for path: ${requestedPath}`);

    // --- Asset Bypass: Check for file extensions OR common asset folder prefixes ---
    const isAsset = ASSET_EXTENSIONS.some(ext => requestedPath.toLowerCase().endsWith(ext)) ||
                    requestedPath.toLowerCase().startsWith('/assets/');

    if (isAsset) {
        console.log(`Bypassing asset request for: ${requestedPath}`);
        // Return 404 to let Netlify serve the static file (which is the correct behavior)
        return {
            statusCode: 404, 
            body: 'Asset request bypassed.',
        };
    }
    // -----------------------------------------------------------------------------

    // Check if the path is a blog post
    if (!requestedPath.startsWith(BLOG_PREFIX) || requestedPath.length <= BLOG_PREFIX.length) {
        return {
            statusCode: 404,
            body: 'Not a blog path.',
        };
    }

    const slug = requestedPath.substring(BLOG_PREFIX.length).split('/')[0];
    let postData = null;

    try {
        const { data, error } = await supabase
            .from('blog_post')
            .select('title, description, featured_image_url, slug')
            .eq('slug', slug)
            .single();

        if (error || !data) {
            console.error(`Supabase error for slug ${slug}:`, error ? error.message : 'No data found');
            return { statusCode: 404, body: 'Post data not found in Supabase.' };
        }
        
        postData = data;
        
    } catch (e) {
        console.error('Server error during data fetch:', e);
        return { statusCode: 500, body: JSON.stringify({ error: 'Internal server error.' }) };
    }
    
    // 4. Construct the Dynamic Meta Tags
    const title = postData.title;
    const description = postData.description;
    const imageUrl = postData.featured_image_url;
    const currentUrl = `https://sosavvy.so${requestedPath}`; 

    const dynamicMetaTags = `
        <title>${title}</title>
        <meta name="description" content="${description}" />
        <meta property="og:url" content="${currentUrl}" />
        <meta property="og:title" content="${title}" />
        <meta property="og:description" content="${description}" />
        <meta property="og:image" content="${imageUrl}" />
        <meta property="og:type" content="article" />
        <meta name="twitter:card" content="summary_large_image" />
        <meta name="twitter:title" content="${title}" />
        <meta name="twitter:description" content="${description}" />
        <meta name="twitter:image" content="${imageUrl}" />
    `;
    
    // 5. Inject the dynamic tags into the template
    let finalHtml = htmlTemplate.replace(PLACEHOLDER, dynamicMetaTags);
    
    // 6. Return the full HTML
    return {
        statusCode: 200,
        headers: {
            "Content-Type": "text/html", // Still must be HTML!
        },
        body: finalHtml,
    };
}
